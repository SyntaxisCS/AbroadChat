import { createCipheriv, createDecipheriv, randomBytes } from "crypto";

const encryptionKey = process.env.PASSKEY_ENCRYPTION_KEY; // New keys can be generated by running crypto.randomBytes(32).toString("hex");
const ivLength = 16;

export const encryptPublicKey = async (publicKey) => {

    const iv = randomBytes(ivLength); // Initialization vector
    const cipher = createCipheriv("aes-256-cbc", Buffer.from(encryptionKey, "hex"), iv);

    // Encrypt public key
    let encrypted = cipher.update(publicKey);
    encrypted = Buffer.concat([encrypted, cipher.final()]);

    // Return the IV and encrypted data, both encoded in Base64
    return `${iv.toString("base64")}:${encrypted.toString("base64")}`;
};

export const decryptPublicKey = async (encryptedText) => {
    const [ivBase64, encryptedDataBase64] = encryptedText.split(":");

    const iv = Buffer.from(ivBase64, "base64");
    const encryptedData = Buffer.from(encryptedDataBase64, "base64");

    // Create cipher
    const deciper = createDecipheriv("aes-256-cbc", Buffer.from(encryptionKey, "hex"), iv);

    // Decrypt
    let decrypted = deciper.update(encryptedData);
    decrypted = Buffer.concat([decrypted, deciper.final()]);

    // Return decrypted
    return decrypted;
};